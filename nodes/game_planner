#!/usr/bin/env python

import rospy
from mini_golf.srv import CV_POIs, CV_POIsResponse, CamCal, CamCalResponse, HitBall, HitBallResponse, InitRobot, InitRobotResponse, MoveBehindBall, MoveBehindBallResponse, DisplayPicture, DisplayPictureResponse
from geometry_msgs.msg import Transform, Pose, Point
import numpy as np
from tf.transformations import quaternion_matrix

def se3_inv(matrix):
    """
    Calculates the inverse of an se(3) transformation matrix.
    """
    R = matrix[0:3,0:3] #roation matrix
    p = matrix[0:3,-1] #translation vector

    RT = np.transpose(R)                        #transpose rotation matrix

    inv_p = -np.matmul(RT, p)                      #invert translation vector

    g = np.zeros((4,4))
    g[0:3,0:3] = RT 
    g[0:3,-1] = inv_p
    g[-1,-1] = 1

    return g                                    #output transformation matrix


class GamePlanner(object):
    def __init__(self):
        #perform subscriptiosn

        #establish publishers

        #establish service proxies
        self.get_camera_cal = rospy.ServiceProxy('/get_camera_cal', CamCal)
        self.get_POIs = rospy.ServiceProxy('/get_pois', CV_POIs)
        self.init_robot = rospy.ServiceProxy('/init_robot', InitRobot)
        self.move_behind_ball = rospy.ServiceProxy('/move_behind_ball', MoveBehindBall)
        self.hit_ball = rospy.ServiceProxy('/hit_ball', HitBall)
        
        #refelects that we might callibrate Tsawyer with camera or just with cuff
        self.arena_callib = "param"
        try:
            self.arena_params = rospy.get_params('/arena')
        except:
            rospy.loginfo("no arena config params loaded into param server, using camera callib data")
            self.arena_callib = "camera"
        
        self.setup_robot()
        rospy.sleep(3) #sleep for 3 seconds to let things chill out
        self.setup_Ts()
        self.loop()

    def setup_robot(self):
        #figure out x,y origin of gamespace in sawyer frame
        #either drag cuff or use our extrinsic camera callibration
        self.init_robot()


    def setup_Ts(self):
        #call camera frame-getting service
        cam_cal_resp = self.get_camera_cal()

        #sawyer & overhead transforms
        sawyer_trans = cam_cal_resp.sawyer_transform
        overhead_trans = cam_cal_resp.overhead_transform

        #sawyer/overhead rotations (quaternion form)
        Q_sawyer_cw = np.array([sawyer_trans.rotation.x,
                                sawyer_trans.rotation.y,
                                sawyer_trans.rotation.z,
                                sawyer_trans.rotation.w])
        Q_overhead_cw = np.array([overhead_trans.rotation.x,
                                  overhead_trans.rotation.y,
                                  overhead_trans.rotation.z,
                                  overhead_trans.rotation.w])
        '''
        Rotation matrices below; in se(3) form
        '''
        R_overhead_cw = quaternion_matrix(Q_overhead_cw)
        print(R_overhead_cw)
        R_sawyer_cw = quaternion_matrix(Q_sawyer_cw)
        print(R_sawyer_cw)

        #sawyer/overhead translation vectors
        p_sawyer_cw = np.array([sawyer_trans.translation.x,
                                sawyer_trans.translation.y,
                                sawyer_trans.translation.z,
                                1])
        p_overhead_cw = np.array([overhead_trans.translation.x,
                                  overhead_trans.translation.y,
                                  overhead_trans.translation.z,
                                  1])

        T_overhead_cw = np.zeros((4, 4))			#blank transformation matrices
        T_sawyer_cw = np.zeros((4, 4))
        T_overhead_cw[0:4, 0:4] = R_overhead_cw		#paste rotation matrices into transformation matrices (Rot mats are output as T mats)
        T_sawyer_cw[0:4, 0:4] = R_sawyer_cw
        T_overhead_cw[:, -1] = p_overhead_cw		#paste translation vectors into transformation matrices
        T_sawyer_cw[:, -1] = p_sawyer_cw

        self.T_overhead_cw = T_overhead_cw
        self.T_sawyer_cw = T_sawyer_cw

    def get_positions(self):
        resp = self.get_POIs()
        #ball position in overhead camera frame
        ball_pos_o = np.array([resp.ball_pose.position.x, resp.ball_pose.position.y, resp.ball_pose.position.z, 1])
        hole_pos_o = np.array([resp.hole_pose.position.x, resp.hole_pose.position.y, resp.hole_pose.position.z, 1])

        #transform to ball and hole positions in game frame
        ball_pos_g = np.matmul(se3_inv(self.T_overhead_cw),ball_pos_o)
        hole_pos_g = np.matmul(se3_inv(self.T_overhead_cw),hole_pos_o)

        #transform to ball and hole positions in sawyer frame
        ball_pos_s = np.matmul(self.T_sawyer_cw, ball_pos_g)
        hole_pos_s = np.matmul(self.T_sawyer_cw, hole_pos_g)

        return ball_pos_s, hole_pos_s

    def move(self, ball_pos, hole_pos):
        # req = MoveBehindBall()
        # req.ball_position.position = Point(ball_pos[0], ball_pos[1], ball_pos[2]) #maybe have Z fixed 
        # req.hole_position.position = Point(hole_pos[0], hole_pos[1], hole_pos[2]) #maybe have Z fixed
        # req.if_add_constraint = False
        ball_pose = Pose()
        hole_pose = Pose()
        # ball_pose.position = Point(ball_pos[0], ball_pos[1], ball_pos[2]) #maybe have Z fixed 
        # hole_pose.position = Point(hole_pos[0], hole_pos[1], hole_pos[2])
        ball_pose.position = Point(0.5, -0.5, 2) #maybe have Z fixed 
        hole_pose.position = Point(0.6, 0.5, hole_pos[2])
        #hole then ball
        print("ball pose is:")
        print(ball_pose)
        print("hole pose is:")
        print(hole_pose)

        self.move_behind_ball(hole_pose, ball_pose, False)

    def loop(self):
        rate = rospy.Rate(2)
        #gets ball and hole positions in sawyer frame
        ball_pos, hole_pos = self.get_positions()
        #tell sawyer to move behind ball in sawyer frame coordinates
        self.move(ball_pos, hole_pos)
        rospy.sleep(10) #dumb sleep for 10 seconds while we get behind ball
        self.hit_ball()

        while not rospy.is_shutdown():
            #get ball position in overhead camera frame coordinate



            rate.sleep()





if __name__ == '__main__':
    rospy.init_node("game_planner")
    GamePlanner()
