#!/usr/bin/env python
''' This node provides a python interface to achieve following functions 
based on the move_it python interface.

- getting robot current state
- planning to a pose goal

PUBLISHERS:
    /move_group/display_planned_path (moveit_msgs.msg.DisplayTrajectory) 
        ~ a DisplayTrajectory publisher which is used to display trajectories in Rviz

'''
from __future__ import division
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from math import pi
import math
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list
import numpy as np
from tf.transformations import quaternion_from_euler

class MoveGroupPythonInterface(object):
    ''' Integrate the functions we need for the mini-golf project as python interface '''
    def __init__(self):
        ''' Initialize RobotCommander, PlanningSceneInterface and MoveGroupCommander objects respectively '''
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        self.group_name = "right_arm"
        self.move_group = moveit_commander.MoveGroupCommander(self.group_name)
        self.display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path',
                                               moveit_msgs.msg.DisplayTrajectory,
                                               queue_size=20)
    

    def current_state(self):
        ''' Get the current state of the robot
        
        Returns:
            current_state : current state of the robot
        '''
        current_state = self.robot.get_current_state()
        return current_state


    def go_to_pose(self, position, orientation):
        ''' Make the end effector go to a pose in task space
        
        Args:
            position (1*3 list e.g. [0.4,0.1,0.4]) : x, y, z coordinates of goal position
            orientation (1*4 list e.g. [0,0,0,1]) : x, y, z, w (quaternion) of a orientation
        '''
        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.position.x = position[0]
        pose_goal.position.y = position[1]
        pose_goal.position.z = position[2]
        pose_goal.orientation.x = orientation[0]
        pose_goal.orientation.y = orientation[1]
        pose_goal.orientation.z = orientation[2]
        pose_goal.orientation.w = orientation[3]

        self.move_group.set_pose_target(pose_goal)

        plan = self.move_group.go(wait=True)

        # Calling `stop()` ensures that there is no residual movement
        self.move_group.stop()

        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        self.move_group.clear_pose_targets()


    def get_start_pose(self, pos_hole, pos_ball, distance = 0.05):
        ''' Calculate the starting pose give the position of the hole and the ball
        
        Args:
            pos_hole (e.g.[0.68,0.27,0.07]): The 3D position (x,y,z) of the hole in the world frame
            pos_ball (e.g.[0.63,-0.34,0.07]): The 3D position (x,y,z) of the ball in the world frame

        Returns:
            position (1*3 list e.g. [0.4,0.1,0.4]) : x, y, z coordinates of the position
            orientation (1*4 list e.g. [0,0,0,1]) : x, y, z, w (quaternion) of the orientation
        '''
        #### Position ####
        # x_s, y_s, z_s denotes the starting position of the center of the putter
        # default distance between the starting position of the putter and the ball is 5cm

        # z_s is same as the height of the ball
        z_s = pos_ball[2]

        # get the vector pointing from the hole to the ball
        v_h2b = (np.array(pos_ball) - np.array(pos_hole))[:2]

        # normalize the vector
        v_h2b_norm = np.linalg.norm(v_h2b)
        v_h2b = v_h2b / v_h2b_norm
        
        # compute x_s, y_s
        x_s = pos_ball[0] + (v_h2b * distance)[0]
        y_s = pos_ball[1] + (v_h2b * distance)[1]

        position =  [x_s, y_s, z_s]

        #### Orientation ####

        # get the angle in xy plane from the vector
        # v_h2b is point from the hole to the ball
        # we need the vector pointing from the ball to the hole
        angle_xy_plane = math.atan2(-v_h2b[1], -v_h2b[0])

        # convert it to euler angle
        euler_yaw = angle_xy_plane
        euler_pitch = pi
        euler_roll = 0

        # convert it to quaternion
        quaternion = quaternion_from_euler(euler_roll, euler_pitch, euler_yaw)
        orientation = [quaternion[0],quaternion[1],quaternion[2],quaternion[3]]

        return position, orientation





if __name__ == '__main__':
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('move_group_python_interface', anonymous=True, log_level=rospy.DEBUG)
    my_sawyer = MoveGroupPythonInterface()
    rospy.loginfo(my_sawyer.current_state())


    position, orientation = my_sawyer.get_start_pose([0.63,-0.34,0.07],[0.68,0.27,0.07])
    rospy.loginfo('The orientation is: %s', orientation)

    my_sawyer.go_to_pose(position,orientation)
    rospy.spin()